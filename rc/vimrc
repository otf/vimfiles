set nocompatible               " be iMproved
set noswapfile
set nobackup
set noundofile
set number                   " 行番号を表示
set clipboard=unnamed        " yとかpとかdでクリップボードを使ってくれる
set list                     " 下のlcsに必須
set lcs=tab:^\               " タブ文字を分かりやすく表示(\の後に空白文字が必要)
set display=uhex             " 表示できない文字を16進表示
set ignorecase               " 下のsmartcaseに必須
set smartcase                " 基本大文字と小文字を無視して検索し、大文字が含まれる場合は無視せずに検索する
set incsearch                " インクリメンタルに検索する
set wrapscan                 " ドキュメントの下まで行ったら一番最初に戻って検索
set hlsearch                 " マッチした語をハイライト表示する

" stataus line
set statusline=%<%f\ %m%r%h%w%y%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%(Base64:%{Dec64()}\ %)%([%{GitBranch()}]%)%l,%c%8P

" tab character
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab

" encoding
"set encoding=utf-8
set fenc=utf-8

" move
for key in ['j', 'k', 'gg', 'G', '{', '}', '[', ']', '[(', '])',
            \ '[{', ']}', ']m', ']M', '[m', '[M', '[#', ']#', '[*', ']*', '[/', ']/',
            \ '%', 'H', 'L', 'w', 'W', 'e', 'ge', 'b', 'B', '<C-d>', '<C-u>', '<C-f>', '<C-b>']
    execute 'nnoremap ' . key . ' ' . key . 'zz'
endfor

" for todo 
command! Todo call OpenFile('~/Dropbox/private/todo.md')

"================================================================================
" vimrc & gvimrc {{{
"================================================================================

function! SourceIfExists(file)
    if filereadable(expand(a:file))
        execute 'source ' . a:file
    endif
    echo 'Reloaded vimrc and gvimrc.'
endfunction

let vimrcbody = '$HOME/_vimrc'
let gvimrcbody = '$HOME/_gvimrc'
function! OpenFile(file)
    let empty_buffer = line('$') == 1 && strlen(getline('1')) == 0
    if empty_buffer && !&modified
        execute 'e ' . a:file
    else
        execute 'tabnew ' . a:file
    endif
endfunction

command! OpenMyVimrc call OpenFile(vimrcbody)
command! OpenMyGVimrc call OpenFile(gvimrcbody)" open vimrc/gvimrc
" reload vimrc and gvimrc
nnoremap <F5> <Esc>:<C-u>source $MYVIMRC<CR>
            \ :source $MYGVIMRC<CR>
            \ :call SourceIfExists('~/vimfiles/ftplugin/' . &filetype . '.vim')<CR>
" open vimrc/gvimrc
nnoremap <Space><Space> :<C-u>OpenMyVimrc<CR>
nnoremap <Space><Tab> :<C-u>OpenMyGVimrc<CR>

"============================================================
" Unite
"============================================================
if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim
  call neobundle#rc(expand('~/.vim/bundle/'))
endif
" originalrepos on github
NeoBundle 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc'
NeoBundle 'VimClojure'
NeoBundle 'Shougo/vimshell'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/neocomplcache'
NeoBundle 'Shougo/neosnippet'
NeoBundle "Shougo/neosnippet-snippets"
NeoBundle 'jpalardy/vim-slime'
NeoBundle 'scrooloose/syntastic'

" for xml
NeoBundle 'xmledit'

" html5の追加タグ
NeoBundle 'three/html5.vim'

" for read cgi
NeoBundle 'koron/chalice'

" for git
NeoBundle 'motemen/git-vim'

" for Haskell
NeoBundle 'kana/vim-filetype-haskell'
NeoBundle 'eagletmt/ghcmod-vim'
NeoBundle 'osyo-manga/vim-watchdogs'
NeoBundle 'thinca/vim-ref'
NeoBundle 'ujihisa/ref-hoogle'
NeoBundle 'lukerandall/haskellmode-vim'
""NeoBundle 'https://bitbucket.org/kovisoft/slimv'

" use ghc functionality for haskell files
au Bufenter *.hs compiler ghc

" switch on syntax highlighting
syntax on

" enable filetype detection, plus loading of filetype plugins
filetype plugin on

" configure browser for haskell_doc.vim
let g:haddock_browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe"

filetype plugin indent on     " required!
filetype indent on
syntax on

"================================================================================
" Base64 {{{
"================================================================================
function! D2B(i)
    let l:work = []
    let l:num = a:i
    while l:num != 0
        call insert(l:work, l:num % 2)
        let l:num = l:num / 2
    endwhile

    let l:result = '000000'
    for i in l:work
        let l:result .= i
    endfor
    return strpart(l:result, len(l:result) - 6)
endfunction
let s:AsciiChars =
            \ "??????????\n\t?\r??" .
            \ '????????????????' .
            \ ' !"#$%&''()*+,-./' .
            \ '0123456789:;<=>?' .
            \ '@ABCDEFGHIJKLMNO' .
            \ 'PQRSTUVWXYZ[\]^_' .
            \ '`abcdefghijklmno' .
            \ 'pqrstuvwxyz{|}~?'
function! Bin2Ch(bin)
    let l:ascii = 0
    let l:ascii += a:bin[0] == '1' ? 128 : 0
    let l:ascii += a:bin[1] == '1' ? 64 : 0
    let l:ascii += a:bin[2] == '1' ? 32 : 0
    let l:ascii += a:bin[3] == '1' ? 16 : 0
    let l:ascii += a:bin[4] == '1' ? 8 : 0
    let l:ascii += a:bin[5] == '1' ? 4 : 0
    let l:ascii += a:bin[6] == '1' ? 2 : 0
    let l:ascii += a:bin[7] == '1' ? 1 : 0
    return s:AsciiChars[l:ascii]
endfunction
let s:Base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function! Dec64()
    let l:row = line(".")
    let l:col = col(".")
    let l:line = getline(l:row)
    let l:from = l:col
    while l:from != 0
        let l:ch = l:line[l:from]
        if l:ch != '=' && stridx(s:Base64Chars, l:ch) == -1
            let l:from += 1
            break
        endif
        let l:from -= 1
    endwhile
    let l:to = l:from + 1
    while l:to < len(l:line)
        let l:ch = l:line[l:to]
        if stridx(s:Base64Chars, l:ch) == -1
            break
        endif
        let l:to += 1
    endwhile
    let l:target = strpart(l:line, l:from, l:to - l:from)
    let l:bin = ''
    for i in range(0, len(l:target) - 1)
        let l:ch = l:target[i]
        let l:idx = stridx(s:Base64Chars, l:ch)
        let l:bin .= D2B(l:idx)
    endfor
    let l:result = ''
    while l:bin != '' && len(l:bin) >= 8
        let l:t = strpart(l:bin, 0, 8)
        let l:bin = strpart(l:bin, 8)
        let l:result .= Bin2Ch(l:t)
    endwhile
    return l:result
endfunction
" }}}
